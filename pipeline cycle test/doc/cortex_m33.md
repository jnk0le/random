# cortex-m33

additional resources:
- https://developer.arm.com/documentation/ka001260/latest/ (`muls` stals for additional cycle)


uses `DWT.CYCCNT`, it must be initialized by application, otherwise will not work
```
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
```

tested on RP2350 (cm33 r1p0)

little glossary:

__operand2__ 
- shifted reg - `add.w r3, r4, r5, ror #24`
- shifted constant - `eor r0, r1, #0x1fc0`
- simple constant - 8bit and 12bit (in `add`/`sub` instruction) constants e.g. `add.w r0, r1, #1` and `add.w r0, r1, #0xff9`
(if 12 bit constant can be created by shifted 8 bits, compiler might use it instead. use `addw`/`subw` as a workaround to force encoding T4)
- constant pattern - pattern constructed from 8bit imm as `0x00XY00XY`,`0xXY00XY00` or `0xXYXYXYXY` e.g. `eor.w r6, r7, #0x1b1b1b1b`

## overall

result latency of operand2 shifted reg/constant, instructions is 2 cycles (can't be chained like multiply accumulates)

`{u,x}xta{b,h,b16}` have 2 cycle result latenct, accumulate dependency can be chained like in multiply accumulates

multiply accumulates have 2 cycle result latency, accumualte dependency can be chained from previous MAC,
`*xta*` or operand2 (shifted reg/constant), insns

`bfi` is a single stage instruction (like the basic ones)

some instructions that execute throghout 2 pipeline stages (2 cycle result latency) and set a condition flags, 
take a total of 2 cycles to execute.\
Affected are: `muls.n` (no .w equivalent) and operand2 shifted constant (inline shifted reg and `movs.w` (any type) are unaffected)

condition flags generated by shifted reg operand2 instructions are available a cycle later than normally

instruction that have been predicated out (within `it` block) are not causing pipeline contention hazards and
allocating it's supposed execution stages at all. (i.e. execute as a `nop`) Therefore it's possible to leak
the condition flags. See [M85 POC](../CM85_predicate_timmingleak_POC_simple.S) for more details.

```
mov.n r10, r10
it eq
addseq.w r0, r1, #0x1fc0 // 2 cycles eq, 1 cycle ne

mov.n r10, r10
it eq
addeq.w r0, r1, r2, ror #23 // 1 cycle
add r0, r3 // 2 cycles eq, 1 cycle ne
```

## "limited dual issue" and branching

only two 16 bit (`.n`) instructions can dual issue (random comment on ycombinator is incorrect)

dual issue pair doesn't need to be aligned at word boundary (but the second op needs to be pre fetched)

`nop` can dual issue with arithmetic or load/store instruction

can't dual issue arithmetic+arithmetic or load/store + aritmetic (as described in M55 optimization guide)
Those also cannot dual issue with `nop` from "slot 1"

not taken branch, can dual issue (from "slot 1") even when preceded with flag generating instruction

```
	subs r7, #1 // 1 cycle (must be .n)
	bne 1b // 2 cycles taken, 0 not taken (must be .n)
	
	adds r3, r4 // 1 cycle (must be .n)
	beq 2f // 2 cycles taken, 0 not taken (must be .n)
```

taken branch, can dual issue (from "slot 1") when preceded by 16 bit instruction that doesn't generate
condition flags. It's effectively executing in 1 cycle.

```
	subs r7, #1 // 1 cycle
	add r0, r1 // 1 cycle (must be .n)
	bne 1b // 1 cycle taken, 0 not taken (must be .n)
```

branch can dual issue with load/store multiple as well

```
	subs r7, #1 // 1 cycle
	ldmia r6!, {r0-r3} // 4 cycles (must be .n)
	bne 1b // 1 cycle taken, 0 not taken (must be .n)
```

`it` can dual issue with preceding instruction, no restrictions on when/where condition flags were generated.

## load/store

load to use latency is 2 cycles

load result can be consumed as MAC accumulate dependency in 1 cycle (`*xta*` or operand2
shifted insns, cannot consume like that)

load to store latency is 1 cycle

can store result from "accumulate" stage in 1 cycle

load/store double execute in 2 cycles (applies to FPU)

load/store multiple of x registers execute in exactly x cycles (applis to FPU)


## fpu

`vldr.32` has 1 cycle of load to use latency

FMA/MLA execute in 1 cycle with 3 cycle of result latency (accumulator has the same input latency as
multipli{er,cand}). No other vloating point instruction can be issued in the following 2 cycles. (including `vldr`/`vstr`)

```
	vfma.f32 s0, s1, s2
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	vfma.f32 s0, s1, s0 // s0 can be used as accumulator or multipli{er,cand} as well
```

`vstr.32` has 1 extra cycle of input latency from FMA

```
	vfma.f32 s0, s1, s2
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	vadd.f32 s30, s30, s31 // can't store yet, can't be FMA
	vstr.32 s0, [r12, #256]
```
