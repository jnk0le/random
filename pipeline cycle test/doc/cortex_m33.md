# cortex-m33

additional resources:
- https://developer.arm.com/documentation/ka001260/latest/ (`muls` stalls for additional cycle)


uses `DWT.CYCCNT`, it must be initialized by application, otherwise will not work
```
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
```

tested on RP2350 (cm33 r1p0)

little glossary:

__operand2__ 
- shifted reg - `add.w r3, r4, r5, ror #24`
- shifted constant - `eor r0, r1, #0x1fc0`
- simple constant - 8bit and 12bit (in `add`/`sub` instruction) constants e.g. `add.w r0, r1, #1` and `add.w r0, r1, #0xff9`
(if 12 bit constant can be created by shifted 8 bits, compiler might use it instead. use `addw`/`subw` as a workaround to force encoding T4)
- constant pattern - pattern constructed from 8bit imm as `0x00XY00XY`,`0xXY00XY00` or `0xXYXYXYXY` e.g. `eor.w r6, r7, #0x1b1b1b1b`

## overall

result latency of operand2 shifted reg/constant, instructions is 2 cycles (can't be chained like multiply accumulates)

`{u,x}xta{b,h,b16}` have 2 cycle result latenct, accumulate dependency can be chained like in multiply accumulates

multiply accumulates have 2 cycle result latency, accumualte dependency can be chained from previous MAC,
`*xta*` or operand2 (shifted reg/constant), insns

`bfi` is a single stage instruction (like the basic ones)

some instructions that execute throghout 2 pipeline stages (2 cycle result latency) and set a condition flags, 
take a total of 2 cycles to execute.\
Affected are: `muls.n` (no .w equivalent) and operand2 shifted constant (inline shifted reg and `movs.w` (any type) are unaffected)

condition flags generated by shifted reg operand2 instructions are available a cycle later than normally

instruction that have been predicated out (within `it` block) are not causing pipeline contention hazards and
allocating it's supposed execution stages at all. (i.e. execute as a `nop`) Therefore it's possible to leak
the condition flags. See [M85 POC](../CM85_predicate_timmingleak_POC_simple.S) for more details.

```
mov.n r10, r10
it eq
addseq.w r0, r1, #0x1fc0 // 2 cycles eq, 1 cycle ne

mov.n r10, r10
it eq
addeq.w r0, r1, r2, ror #23 // 1 cycle
add r0, r3 // 2 cycles eq, 1 cycle ne
```

## "limited dual issue" and branching

only two 16 bit (`.n`) instructions can dual issue (random comment on ycombinator is incorrect)

dual issue pair doesn't need to be aligned at word boundary (but the second op needs to be pre fetched)

`nop` can dual issue with arithmetic or load/store instruction

can't dual issue arithmetic+arithmetic or load/store + aritmetic (as described in M55 optimization guide)
Those also cannot dual issue with `nop` from "slot 1"

not taken branch, can dual issue (from "slot 1") even when preceded with flag generating instruction

```
	subs r7, #1 // 1 cycle (must be .n)
	bne 1b // 2 cycles taken, 0 not taken (must be .n)
	
	adds r3, r4 // 1 cycle (must be .n)
	beq 2f // 2 cycles taken, 0 not taken (must be .n)
```

taken branch, can dual issue (from "slot 1") when preceded by 16 bit instruction that doesn't generate
condition flags. It's effectively executing in 1 cycle.

```
	subs r7, #1 // 1 cycle
	add r0, r1 // 1 cycle (must be .n)
	bne 1b // 1 cycle taken, 0 not taken (must be .n)
```

branch can dual issue with load/store multiple as well

```
	subs r7, #1 // 1 cycle
	ldmia r6!, {r0-r3} // 4 cycles (must be .n)
	bne 1b // 1 cycle taken, 0 not taken (must be .n)
```

`it` can dual issue with preceding instruction, no restrictions on when/where condition flags were generated.

## load/store

load to use latency is 2 cycles

load result can be consumed as MAC accumulate dependency in 1 cycle (`*xta*` or operand2
shifted insns, cannot consume like that)

load to store latency is 1 cycle

can store result from "accumulate" stage in 1 cycle

load/store double execute in 2 cycles (applies to FPU)

load/store multiple of x registers execute in exactly x cycles (applis to FPU)


## fpu

`vldr.32` has 1 cycle of load to use latency

FMA/MLA execute in 1 cycle with 3 cycle of result latency into accumulator of another FMA or 4 as
multipli{er, cand}. No other vloating point instruction can be issued in the following 2 cycles. (including `vldr`/`vstr`)

```
	vfma.f32 s0, s1, s2
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	vfma.f32 s0, s3, s4 // s0 can be used as accumulator
```

```
	vfma.f32 s0, s1, s2
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	vadd.f32 s30, s30, s31
	vfma.f32 s4, s3, s0 // s0 can be used by anything else
```

result latency of every other FP compute instruction (`vadd.f32`, `vmul.f32`) is 2 cycles.
Those are pipelined so can be issued every cycle.\
Therefore each of the unfused multiply accumulate operations can be
performed in 2 cycles total, by appropriately interleaving accumulations.

```
	// can be scheduled like that (two accumulators)
	vmul.f32 s0, s1, s2
	vmul.f32 s4, s5, s6
	vadd.f32 s3, s3, s0
	vadd.f32 s7, s7, s4

	// or like that (single accumulator)
	vmul.f32 s0, s1, s2
	vmul.f32 s3, s4, s5
	vadd.f32 s30, s30, s0
	vmul.f32 s6, s7, s8
	vadd.f32 s30, s30, s3
	vmul.f32 s9, s10, s11
	vadd.f32 s30, s30, s6
	mov.n r10, r10
	vadd.f32 s30, s30, s9
```


Can issue vloating point instruction (`vadd.f32`, `vfma.f32`) a cycle before one of it's
operands is availale. The offending instruction will then execute "out of order".\
issuing further FPU instructions (even not dependent in first cycle) will result in a stall.\
Therefore you will encounter some anomalies when testing the FPU code.

```
	vmul.f32 s0, s1, s2
	vadd.f32 s3, s0, s4
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // insn with s3 dependency will issue "out of order" here
	vstr s3, [r12, #256]
```

FMA issues "out of order" only on multipli{er,cand} dependency.

```
	vadd.f32 s1, s4, s5
	vfma.f32 s0, s1, s2
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	mov.n r10, r10 // can't use vloating point insns
	vfma.f32 s0, s1, s2 // insn with s0 dependency will issue "out of order" here (except FMA accumulator)
```

`vstr.32` can't be issued "out of order", even after non related FP instruction that has been issued "out of order"
